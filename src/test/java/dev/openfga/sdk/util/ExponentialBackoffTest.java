/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import static org.assertj.core.api.Assertions.assertThat;

import java.time.Duration;
import java.util.Random;
import org.junit.jupiter.api.Test;

class ExponentialBackoffTest {

    @Test
    void calculateDelay_withRetryCountZero_shouldReturnBaseDelay() {
        // Given
        int retryCount = 0;
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, fixedRandom);

        // Then
        // For retry count 0: 2^0 * 500ms = 500ms base
        // With jitter: between 500ms and 1000ms
        assertThat(result.toMillis()).isBetween(500L, 1000L);
    }

    @Test
    void calculateDelay_withRetryCountOne_shouldReturnDoubledDelay() {
        // Given
        int retryCount = 1;
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, fixedRandom);

        // Then
        // For retry count 1: 2^1 * 500ms = 1000ms base
        // With jitter: between 1000ms and 2000ms
        assertThat(result.toMillis()).isBetween(1000L, 2000L);
    }

    @Test
    void calculateDelay_withRetryCountTwo_shouldReturnQuadrupledDelay() {
        // Given
        int retryCount = 2;
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, fixedRandom);

        // Then
        // For retry count 2: 2^2 * 500ms = 2000ms base
        // With jitter: between 2000ms and 4000ms
        assertThat(result.toMillis()).isBetween(2000L, 4000L);
    }

    @Test
    void calculateDelay_withHighRetryCount_shouldCapAtMaximum() {
        // Given
        int retryCount = 10; // This would normally result in 2^10 * 500ms = 512000ms
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, fixedRandom);

        // Then
        // Should be capped at 120 seconds (120000ms)
        assertThat(result.toMillis()).isLessThanOrEqualTo(120000L);
    }

    @Test
    void calculateDelay_withNegativeRetryCount_shouldReturnZero() {
        // Given
        int retryCount = -1;

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount);

        // Then
        assertThat(result).isEqualTo(Duration.ZERO);
    }

    @Test
    void calculateDelay_withoutRandomParameter_shouldReturnValidRange() {
        // Given
        int retryCount = 1;

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount);

        // Then
        // For retry count 1: 2^1 * 500ms = 1000ms base
        // With jitter: between 1000ms and 2000ms
        assertThat(result.toMillis()).isBetween(1000L, 2000L);
    }

    @Test
    void calculateDelay_shouldProduceVariousResults() {
        // Given
        int retryCount = 1;

        // When - call multiple times to ensure randomness
        Duration result1 = ExponentialBackoff.calculateDelay(retryCount);
        Duration result2 = ExponentialBackoff.calculateDelay(retryCount);
        Duration result3 = ExponentialBackoff.calculateDelay(retryCount);

        // Then - all should be in valid range but likely different
        assertThat(result1.toMillis()).isBetween(1000L, 2000L);
        assertThat(result2.toMillis()).isBetween(1000L, 2000L);
        assertThat(result3.toMillis()).isBetween(1000L, 2000L);
    }

    @Test
    void calculateDelay_withFixedRandom_shouldBeDeterministic() {
        // Given
        int retryCount = 1;
        Random fixedRandom1 = new Random(123);
        Random fixedRandom2 = new Random(123); // Same seed

        // When
        Duration result1 = ExponentialBackoff.calculateDelay(retryCount, fixedRandom1);
        Duration result2 = ExponentialBackoff.calculateDelay(retryCount, fixedRandom2);

        // Then
        assertThat(result1).isEqualTo(result2);
    }

    @Test
    void calculateDelay_progressionTest_shouldFollowExponentialPattern() {
        // Given
        Random fixedRandom = new Random(42);

        // When & Then - test the progression follows expected pattern
        for (int i = 0; i < 8; i++) {
            // Reset the random seed for consistent results across iterations
            fixedRandom.setSeed(42);
            Duration delay = ExponentialBackoff.calculateDelay(i, fixedRandom);
            long expectedBaseMs = (long) Math.pow(2, i) * 500;
            long expectedMaxMs = Math.min(expectedBaseMs * 2, 120000);

            assertThat(delay.toMillis())
                    .describedAs(
                            "Retry count %d should have delay between %d and %d ms", i, expectedBaseMs, expectedMaxMs)
                    .isBetween(expectedBaseMs, expectedMaxMs);
        }
    }

    @Test
    void calculateDelay_atCapThreshold_shouldCapCorrectly() {
        // Given - retry count that would exceed 120s base delay
        int retryCount = 8; // 2^8 * 500ms = 128000ms > 120000ms
        Random fixedRandom = new Random(42);

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, fixedRandom);

        // Then - should be capped at 120s maximum
        assertThat(result.toMillis()).isLessThanOrEqualTo(120000L);
        assertThat(result.toMillis()).isGreaterThanOrEqualTo(120000L); // Should be exactly at cap for base delay
    }
}
