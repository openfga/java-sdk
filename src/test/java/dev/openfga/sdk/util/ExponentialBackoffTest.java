/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.time.Duration;
import java.util.Random;
import org.junit.jupiter.api.Test;

class ExponentialBackoffTest {

    @Test
    void calculateDelay_withRetryCountZero_shouldReturnBaseDelay() {
        // Given
        int retryCount = 0;
        Duration baseDelay = Duration.ofMillis(100);
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom);

        // Then
        // For retry count 0: 2^0 * 100ms = 100ms base
        // With jitter: between 100ms and 200ms
        assertThat(result.toMillis()).isBetween(100L, 200L);
    }

    @Test
    void calculateDelay_withRetryCountOne_shouldReturnDoubledDelay() {
        // Given
        int retryCount = 1;
        Duration baseDelay = Duration.ofMillis(100);
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom);

        // Then
        // For retry count 1: 2^1 * 100ms = 200ms base
        // With jitter: between 200ms and 400ms
        assertThat(result.toMillis()).isBetween(200L, 400L);
    }

    @Test
    void calculateDelay_withRetryCountTwo_shouldReturnQuadrupledDelay() {
        // Given
        int retryCount = 2;
        Duration baseDelay = Duration.ofMillis(100);
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom);

        // Then
        // For retry count 2: 2^2 * 100ms = 400ms base
        // With jitter: between 400ms and 800ms
        assertThat(result.toMillis()).isBetween(400L, 800L);
    }

    @Test
    void calculateDelay_withHighRetryCount_shouldCapAtMaximum() {
        // Given
        int retryCount = 10; // This would normally result in 2^10 * 100ms = 102400ms
        Duration baseDelay = Duration.ofMillis(100);
        Random fixedRandom = new Random(42); // Fixed seed for deterministic testing

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom);

        // Then
        // Should be capped at 120 seconds (120000ms)
        assertThat(result.toMillis()).isLessThanOrEqualTo(120000L);
    }

    @Test
    void calculateDelay_withNegativeRetryCount_shouldReturnZero() {
        // Given
        int retryCount = -1;

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, Duration.ofMillis(100));

        // Then
        assertThat(result).isEqualTo(Duration.ZERO);
    }

    @Test
    void calculateDelay_withoutRandomParameter_shouldReturnValidRange() {
        // Given
        int retryCount = 1;

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, Duration.ofMillis(100));

        // Then
        // For retry count 1: 2^1 * 100ms = 200ms base
        // With jitter: between 200ms and 400ms
        assertThat(result.toMillis()).isBetween(200L, 400L);
    }

    @Test
    void calculateDelay_shouldProduceVariousResults() {
        // Given
        int retryCount = 1;

        // When - call multiple times to ensure randomness
        Duration result1 = ExponentialBackoff.calculateDelay(retryCount, Duration.ofMillis(100));
        Duration result2 = ExponentialBackoff.calculateDelay(retryCount, Duration.ofMillis(100));
        Duration result3 = ExponentialBackoff.calculateDelay(retryCount, Duration.ofMillis(100));

        // Then - all should be in valid range but likely different
        assertThat(result1.toMillis()).isBetween(200L, 400L);
        assertThat(result2.toMillis()).isBetween(200L, 400L);
        assertThat(result3.toMillis()).isBetween(200L, 400L);
    }

    @Test
    void calculateDelay_withFixedRandom_shouldBeDeterministic() {
        // Given
        int retryCount = 1;
        Duration baseDelay = Duration.ofMillis(100);
        Random fixedRandom1 = new Random(123);
        Random fixedRandom2 = new Random(123); // Same seed

        // When
        Duration result1 = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom1);
        Duration result2 = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom2);

        // Then
        assertThat(result1).isEqualTo(result2);
    }

    @Test
    void calculateDelay_progressionTest_shouldFollowExponentialPattern() {
        // Given
        Duration baseDelay = Duration.ofMillis(100);
        Random fixedRandom = new Random(42);

        // When & Then - test the progression follows expected pattern
        for (int i = 0; i < 8; i++) {
            // Reset the random seed for consistent results across iterations
            fixedRandom.setSeed(42);
            Duration delay = ExponentialBackoff.calculateDelay(i, baseDelay, fixedRandom);
            long expectedBaseMs = (long) Math.pow(2, i) * 100;
            long expectedMaxMs = Math.min(expectedBaseMs * 2, 120000);

            assertThat(delay.toMillis())
                    .describedAs(
                            "Retry count %d should have delay between %d and %d ms", i, expectedBaseMs, expectedMaxMs)
                    .isBetween(expectedBaseMs, expectedMaxMs);
        }
    }

    @Test
    void calculateDelay_atCapThreshold_shouldCapCorrectly() {
        // Given - retry count that would exceed 120s base delay
        int retryCount = 11; // 2^11 * 100ms = 204800ms > 120000ms
        Duration baseDelay = Duration.ofMillis(100);
        Random fixedRandom = new Random(42);

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom);

        // Then - should be capped at 120s maximum
        assertThat(result.toMillis()).isLessThanOrEqualTo(120000L);
        assertThat(result.toMillis()).isGreaterThanOrEqualTo(120000L); // Should be exactly at cap for base delay
    }

    @Test
    void calculateDelay_withCustomBaseDelay_shouldUseConfigurableBase() {
        // Given - custom base delay of 500ms
        int retryCount = 1;
        Duration baseDelay = Duration.ofMillis(500);
        Random fixedRandom = new Random(42);

        // When
        Duration result = ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom);

        // Then
        // For retry count 1 with 500ms base: 2^1 * 500ms = 1000ms base
        // With jitter: between 1000ms and 2000ms
        assertThat(result.toMillis()).isBetween(1000L, 2000L);
    }

    @Test
    void calculateDelay_withNullBaseDelay_shouldThrowException() {
        // Given
        int retryCount = 0;
        Duration baseDelay = null;
        Random fixedRandom = new Random(42);

        // When & Then
        assertThatThrownBy(() -> ExponentialBackoff.calculateDelay(retryCount, baseDelay, fixedRandom))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("baseDelay cannot be null");
    }
}
