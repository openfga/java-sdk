/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import static org.assertj.core.api.Assertions.assertThat;

import java.time.Duration;
import java.util.Optional;
import org.junit.jupiter.api.Test;

class RetryStrategyTest {

    @Test
    void calculateRetryDelay_withRetryAfterHeader_shouldUseRetryAfterValue() {
        // Given
        Optional<Duration> retryAfterDelay = Optional.of(Duration.ofMillis(5000));
        int retryCount = 1;
        Duration minimumRetryDelay = Duration.ofMillis(100);

        // When
        Duration result = RetryStrategy.calculateRetryDelay(retryAfterDelay, retryCount, minimumRetryDelay);

        // Then
        assertThat(result).isEqualTo(Duration.ofMillis(5000));
    }

    @Test
    void calculateRetryDelay_withRetryAfterSmallerThanMinimum_shouldUseRetryAfter() {
        // Given
        Optional<Duration> retryAfterDelay = Optional.of(Duration.ofMillis(50));
        int retryCount = 1;
        Duration minimumRetryDelay = Duration.ofMillis(200);

        // When
        Duration result = RetryStrategy.calculateRetryDelay(retryAfterDelay, retryCount, minimumRetryDelay);

        // Then
        assertThat(result).isEqualTo(Duration.ofMillis(50));
    }

    @Test
    void calculateRetryDelay_withoutRetryAfter_shouldUseMinimumAsBaseDelay() {
        // Given
        Optional<Duration> retryAfterDelay = Optional.empty();
        int retryCount = 1;
        Duration minimumRetryDelay = Duration.ofMillis(500);

        // When
        Duration result = RetryStrategy.calculateRetryDelay(retryAfterDelay, retryCount, minimumRetryDelay);

        // Then
        // For retry count 1 with 500ms base: 2^1 * 500ms = 1000ms base
        // With jitter: between 1000ms and 2000ms
        assertThat(result.toMillis()).isBetween(1000L, 2000L);
    }

    @Test
    void calculateRetryDelay_withNullMinimum_shouldUseDefaultBase() {
        // Given
        Optional<Duration> retryAfterDelay = Optional.empty();
        int retryCount = 1;
        Duration minimumRetryDelay = null;

        // When
        Duration result = RetryStrategy.calculateRetryDelay(retryAfterDelay, retryCount, minimumRetryDelay);

        // Then
        // Should use default 100ms base delay
        // For retry count 1: 2^1 * 100ms = 200ms base
        // With jitter: between 200ms and 400ms
        assertThat(result.toMillis()).isBetween(200L, 400L);
    }

    @Test
    void shouldRetry_with429_shouldReturnTrue() {
        assertThat(RetryStrategy.shouldRetry(429)).isTrue();
    }

    @Test
    void shouldRetry_with500_shouldReturnTrue() {
        assertThat(RetryStrategy.shouldRetry(500)).isTrue();
    }

    @Test
    void shouldRetry_with502_shouldReturnTrue() {
        assertThat(RetryStrategy.shouldRetry(502)).isTrue();
    }

    @Test
    void shouldRetry_with503_shouldReturnTrue() {
        assertThat(RetryStrategy.shouldRetry(503)).isTrue();
    }

    @Test
    void shouldRetry_with504_shouldReturnTrue() {
        assertThat(RetryStrategy.shouldRetry(504)).isTrue();
    }

    @Test
    void shouldRetry_with400_shouldReturnFalse() {
        assertThat(RetryStrategy.shouldRetry(400)).isFalse();
    }

    @Test
    void shouldRetry_with404_shouldReturnFalse() {
        assertThat(RetryStrategy.shouldRetry(404)).isFalse();
    }

    @Test
    void shouldRetry_with501_shouldReturnFalse() {
        assertThat(RetryStrategy.shouldRetry(501)).isFalse();
    }
}
