/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import dev.openfga.sdk.errors.HttpStatusCode;
import java.net.URI;
import java.net.http.HttpRequest;
import java.time.Duration;
import java.util.Optional;
import org.junit.jupiter.api.Test;

class RetryStrategyTest {

    @Test
    void shouldRetryGetRequestOn429() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .GET()
                .build();

        boolean result = RetryStrategy.shouldRetry(request, 429, false);
        assertThat(result).isTrue();
    }

    @Test
    void shouldRetryPostRequestOn429() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .POST(HttpRequest.BodyPublishers.ofString("{}"))
                .build();

        boolean result = RetryStrategy.shouldRetry(request, 429, false);
        assertThat(result).isTrue();
    }

    @Test
    void shouldRetryGetRequestOn500() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .GET()
                .build();

        boolean result = RetryStrategy.shouldRetry(request, 500, false);
        assertThat(result).isTrue();
    }

    @Test
    void shouldRetryPostRequestOn500() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .POST(HttpRequest.BodyPublishers.ofString("{}"))
                .build();

        // Breaking change: POST requests should NOT retry on 5xx without Retry-After header
        boolean result = RetryStrategy.shouldRetry(request, 500, false);
        assertThat(result).isFalse();
    }

    @Test
    void shouldRetryPostRequestOn500WithRetryAfter() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .POST(HttpRequest.BodyPublishers.ofString("{}"))
                .build();

        boolean result = RetryStrategy.shouldRetry(request, 500, true);
        assertThat(result).isTrue();
    }

    @Test
    void shouldRetryPutRequestOn502() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .PUT(HttpRequest.BodyPublishers.ofString("{}"))
                .build();

        // Breaking change: PUT requests should NOT retry on 5xx without Retry-After header
        boolean result = RetryStrategy.shouldRetry(request, 502, false);
        assertThat(result).isFalse();
    }

    @Test
    void shouldRetryPatchRequestOn503() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .method("PATCH", HttpRequest.BodyPublishers.ofString("{}"))
                .build();

        // Breaking change: PATCH requests should NOT retry on 5xx without Retry-After header
        boolean result = RetryStrategy.shouldRetry(request, 503, false);
        assertThat(result).isFalse();
    }

    @Test
    void shouldRetryDeleteRequestOn504() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .DELETE()
                .build();

        // Breaking change: DELETE requests should NOT retry on 5xx without Retry-After header
        boolean result = RetryStrategy.shouldRetry(request, 504, false);
        assertThat(result).isFalse();
    }

    @Test
    void shouldRetry_with501Status_shouldReturnFalseRegardlessOfMethod() {
        // Given
        HttpRequest getRequest = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .GET()
                .build();
        HttpRequest postRequest = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .POST(HttpRequest.BodyPublishers.ofString("{}"))
                .build();
        int statusCode = HttpStatusCode.NOT_IMPLEMENTED;
        boolean hasRetryAfterHeader = true;

        // When & Then
        assertThat(RetryStrategy.shouldRetry(getRequest, statusCode, hasRetryAfterHeader))
                .isFalse();
        assertThat(RetryStrategy.shouldRetry(postRequest, statusCode, hasRetryAfterHeader))
                .isFalse();
    }

    @Test
    void shouldNotRetryOn400() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com/test"))
                .GET()
                .build();

        boolean result = RetryStrategy.shouldRetry(request, 400, false);
        assertThat(result).isFalse();
    }

    @Test
    void shouldRetry_withNonStateAffectingMethods_shouldAlwaysRetryOn5xx() {
        // Given
        String[] nonStateAffectingMethods = {"GET", "HEAD", "OPTIONS"};
        int serverErrorStatus = 502;

        for (String method : nonStateAffectingMethods) {
            HttpRequest request = createMockRequest(method);

            // Without Retry-After header
            assertThat(RetryStrategy.shouldRetry(request, serverErrorStatus, false))
                    .describedAs("Method %s without Retry-After should still retry on 5xx", method)
                    .isTrue();

            // With Retry-After header
            assertThat(RetryStrategy.shouldRetry(request, serverErrorStatus, true))
                    .describedAs("Method %s with Retry-After should retry on 5xx", method)
                    .isTrue();
        }
    }

    @Test
    void shouldRetry_with4xxStatusExcept429_shouldReturnFalse() {
        // Given
        HttpRequest request = createMockRequest("GET");
        int[] clientErrorStatuses = {400, 401, 403, 404, 422};

        for (int statusCode : clientErrorStatuses) {
            // When & Then
            assertThat(RetryStrategy.shouldRetry(request, statusCode, false))
                    .describedAs("Status %d should not be retryable", statusCode)
                    .isFalse();
            assertThat(RetryStrategy.shouldRetry(request, statusCode, true))
                    .describedAs("Status %d should not be retryable even with Retry-After", statusCode)
                    .isFalse();
        }
    }

    @Test
    void shouldRetry_with2xxStatus_shouldReturnFalse() {
        // Given
        HttpRequest request = createMockRequest("GET");
        int[] successStatuses = {200, 201, 204};

        for (int statusCode : successStatuses) {
            // When & Then
            assertThat(RetryStrategy.shouldRetry(request, statusCode, false))
                    .describedAs("Status %d should not be retryable", statusCode)
                    .isFalse();
        }
    }

    @Test
    void calculateRetryDelay_withRetryAfterHeader_shouldUseHeaderValue() {
        // Given
        Optional<Duration> retryAfterDelay = Optional.of(Duration.ofSeconds(30));
        int retryCount = 2;

        // When
        Duration result = RetryStrategy.calculateRetryDelay(retryAfterDelay, retryCount);

        // Then
        assertThat(result).isEqualTo(Duration.ofSeconds(30));
    }

    @Test
    void calculateRetryDelay_withoutRetryAfterHeader_shouldUseExponentialBackoff() {
        // Given
        Optional<Duration> retryAfterDelay = Optional.empty();
        int retryCount = 1;

        // When
        Duration result = RetryStrategy.calculateRetryDelay(retryAfterDelay, retryCount);

        // Then
        // For retry count 1: 2^1 * 100ms = 200ms base, with jitter between 200ms and 400ms
        assertThat(result.toMillis()).isBetween(200L, 400L);
    }

    @Test
    void calculateRetryDelay_withEmptyRetryAfterHeader_shouldUseExponentialBackoff() {
        // Given
        Optional<Duration> retryAfterDelay = Optional.empty();
        int retryCount = 0;

        // When
        Duration result = RetryStrategy.calculateRetryDelay(retryAfterDelay, retryCount);

        // Then
        // For retry count 0: 2^0 * 100ms = 100ms base, with jitter between 100ms and 200ms
        assertThat(result.toMillis()).isBetween(100L, 200L);
    }

    @Test
    void shouldRetry_withCaseInsensitiveMethods_shouldWorkCorrectly() {
        // Given
        HttpRequest lowerCaseRequest = createMockRequest("post");
        HttpRequest upperCaseRequest = createMockRequest("POST");
        HttpRequest mixedCaseRequest = createMockRequest("Post");
        int statusCode = 500;
        boolean hasRetryAfterHeader = true;

        // When & Then
        assertThat(RetryStrategy.shouldRetry(lowerCaseRequest, statusCode, hasRetryAfterHeader))
                .isTrue();
        assertThat(RetryStrategy.shouldRetry(upperCaseRequest, statusCode, hasRetryAfterHeader))
                .isTrue();
        assertThat(RetryStrategy.shouldRetry(mixedCaseRequest, statusCode, hasRetryAfterHeader))
                .isTrue();
    }

    private HttpRequest createMockRequest(String method) {
        HttpRequest request = mock(HttpRequest.class);
        when(request.method()).thenReturn(method);
        when(request.uri()).thenReturn(URI.create("https://api.example.com/test"));
        return request;
    }
}
