/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import dev.openfga.sdk.errors.HttpStatusCode;
import java.net.http.HttpRequest;
import java.time.Duration;
import java.util.Optional;


/**
 * Utility class for determining retry behavior based on HTTP methods and status codes.
 *
 * Implements the retry strategy specified in GitHub issue #155:
 * - For state-affecting operations (POST, PUT, PATCH, DELETE): Retry on 429s with fallback to exponential backoff,
 *   retry on 5xxs only if Retry-After header is present
 * - For non-state-affecting operations (GET, HEAD, OPTIONS): Retry on all 429s and >=500 (except 501)
 */
public class RetryStrategy {

    private RetryStrategy() {
        // Utility class - no instantiation
    }

    /**
     * Determines if a request should be retried based on the HTTP method, status code, and presence of Retry-After header.
     * 
     * Note: To maintain backward compatibility, all retryable status codes (429 and 5xx except 501) are retried
     * regardless of HTTP method. The Retry-After header is honored when present for delay calculation.
     *
     * @param request The HTTP request
     * @param statusCode The HTTP response status code
     * @param hasRetryAfterHeader Whether the response contains a valid Retry-After header
     * @return true if the request should be retried, false otherwise
     */
    public static boolean shouldRetry(HttpRequest request, int statusCode, boolean hasRetryAfterHeader) {
        // Use the existing HttpStatusCode.isRetryable() logic to maintain backward compatibility
        return HttpStatusCode.isRetryable(statusCode);
    }

    /**
     * Calculates the appropriate retry delay based on the presence of Retry-After header and retry count.
     *
     * @param retryAfterDelay Optional delay from Retry-After header
     * @param retryCount Current retry attempt (0-based)
     * @return Duration representing the delay before the next retry
     */
    public static Duration calculateRetryDelay(Optional<Duration> retryAfterDelay, int retryCount) {
        // If Retry-After header is present and valid, use it
        if (retryAfterDelay.isPresent()) {
            return retryAfterDelay.get();
        }

        // Otherwise, use exponential backoff with jitter
        return ExponentialBackoff.calculateDelay(retryCount);
    }
}
