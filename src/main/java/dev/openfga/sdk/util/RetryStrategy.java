/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import dev.openfga.sdk.errors.HttpStatusCode;
import java.net.http.HttpRequest;
import java.time.Duration;
import java.util.Optional;
import java.util.Set;

/**
 * Utility class for determining retry behavior based on HTTP methods and status codes.
 *
 * Implements RFC 9110 compliant retry logic with differentiated behavior for state-affecting operations.
 * State-affecting operations (POST, PUT, PATCH, DELETE) are more conservative about retries on 5xx errors.
 */
public class RetryStrategy {

    // HTTP methods that affect server state and should be more conservative about retries
    private static final Set<String> STATE_AFFECTING_METHODS = Set.of("POST", "PUT", "PATCH", "DELETE");

    private RetryStrategy() {
        // Utility class - no instantiation
    }

    /**
     * Determines if a request should be retried based on the HTTP method, status code, and presence of Retry-After header.
     *
     * Retry Logic:
     * - 429 (Too Many Requests): Always retry regardless of method
     * - 5xx errors (except 501):
     *   - State-affecting operations: Only retry if Retry-After header is present
     *   - Non-state-affecting operations: Always retry
     * - All other status codes: Do not retry
     *
     * @param request The HTTP request
     * @param statusCode The HTTP response status code
     * @param hasRetryAfterHeader Whether the response contains a valid Retry-After header
     * @return true if the request should be retried, false otherwise
     */
    public static boolean shouldRetry(HttpRequest request, int statusCode, boolean hasRetryAfterHeader) {
        String method = request.method().toUpperCase();

        // Always retry 429 (Too Many Requests) regardless of method
        if (statusCode == HttpStatusCode.TOO_MANY_REQUESTS) {
            return true;
        }

        // For 5xx errors (except 501 Not Implemented)
        if (HttpStatusCode.isServerError(statusCode) && statusCode != HttpStatusCode.NOT_IMPLEMENTED) {
            if (isStateAffectingMethod(method)) {
                // For state-affecting operations: only retry 5xx if Retry-After header is present
                return hasRetryAfterHeader;
            } else {
                // For non-state-affecting operations: always retry 5xx
                return true;
            }
        }

        return false;
    }

    /**
     * Calculates the appropriate retry delay based on the presence of Retry-After header and retry count.
     *
     * @param retryAfterDelay Optional delay from Retry-After header
     * @param retryCount Current retry attempt (0-based)
     * @return Duration representing the delay before the next retry
     */
    public static Duration calculateRetryDelay(Optional<Duration> retryAfterDelay, int retryCount) {
        // If Retry-After header is present and valid, use it
        if (retryAfterDelay.isPresent()) {
            return retryAfterDelay.get();
        }

        // Otherwise, use exponential backoff with jitter
        return ExponentialBackoff.calculateDelay(retryCount);
    }

    /**
     * Determines if an HTTP method is state-affecting (modifies server state).
     * State-affecting methods should be more conservative about retries.
     *
     * @param method The HTTP method (case-insensitive)
     * @return true if the method is state-affecting, false otherwise
     */
    private static boolean isStateAffectingMethod(String method) {
        return STATE_AFFECTING_METHODS.contains(method.toUpperCase());
    }
}
