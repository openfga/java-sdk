/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import dev.openfga.sdk.errors.HttpStatusCode;
import java.net.http.HttpRequest;
import java.time.Duration;
import java.util.Optional;

/**
 * Utility class for determining retry behavior based on HTTP status codes.
 *
 * Implements simplified retry logic per GitHub issue #155:
 * - Retry on 429s for all requests
 * - Retry on 5xx errors (except 501) for all requests
 * - Honor Retry-After header when present, fallback to exponential backoff
 */
public class RetryStrategy {

    private RetryStrategy() {
        // Utility class - no instantiation
    }

    /**
     * Determines if a request should be retried based on the status code.
     *
     * Simplified Retry Logic per GitHub issue #155:
     * - 429 (Too Many Requests): Always retry for all requests
     * - 5xx errors (except 501): Always retry for all requests
     * - All other status codes: Do not retry
     *
     * @param request The HTTP request (kept for API compatibility)
     * @param statusCode The HTTP response status code
     * @param hasRetryAfterHeader Whether the response contains a valid Retry-After header (kept for API compatibility)
     * @return true if the request should be retried, false otherwise
     */
    public static boolean shouldRetry(HttpRequest request, int statusCode, boolean hasRetryAfterHeader) {
        // Always retry 429 (Too Many Requests) for all requests
        if (statusCode == HttpStatusCode.TOO_MANY_REQUESTS) {
            return true;
        }

        // Always retry 5xx errors (except 501 Not Implemented) for all requests
        if (HttpStatusCode.isServerError(statusCode) && statusCode != HttpStatusCode.NOT_IMPLEMENTED) {
            return true;
        }

        return false;
    }

    /**
     * Calculates the appropriate retry delay based on the presence of Retry-After header and retry count.
     *
     * @param retryAfterDelay Optional delay from Retry-After header
     * @param retryCount Current retry attempt (0-based)
     * @return Duration representing the delay before the next retry
     */
    public static Duration calculateRetryDelay(Optional<Duration> retryAfterDelay, int retryCount) {
        // If Retry-After header is present and valid, use it
        if (retryAfterDelay.isPresent()) {
            return retryAfterDelay.get();
        }

        // Otherwise, use exponential backoff with jitter
        return ExponentialBackoff.calculateDelay(retryCount);
    }
}
