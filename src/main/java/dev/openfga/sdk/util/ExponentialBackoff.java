/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import dev.openfga.sdk.constants.FgaConstants;
import java.time.Duration;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Utility class for calculating exponential backoff delays with jitter.
 *
 * Implements the retry strategy specified in GitHub issue #155:
 * - Base delay: 2^retryCount * baseDelay (configurable)
 * - Jitter: Random value between base and 2 * base
 * - Maximum delay: 120 seconds (capped after 10th retry)
 */
public class ExponentialBackoff {

    private static final int MAX_DELAY_SECONDS = FgaConstants.MAX_BACKOFF_TIME_IN_SEC;

    private ExponentialBackoff() {
        // Utility class - no instantiation
    }

    /**
     * Calculates the exponential backoff delay with jitter for a given retry attempt.
     *
     * @param retryCount The current retry attempt (0-based, so first retry is 0)
     * @param baseDelay The base delay to use for exponential calculation
     * @return Duration representing the delay before the next retry
     */
    public static Duration calculateDelay(int retryCount, Duration baseDelay) {
        return calculateDelay(retryCount, baseDelay, ThreadLocalRandom.current());
    }

    /**
     * Calculates the exponential backoff delay with jitter using a provided Random instance.
     * This method is primarily for testing purposes to ensure deterministic behavior.
     *
     * @param retryCount The current retry attempt (0-based, so first retry is 0)
     * @param baseDelay The base delay to use for exponential calculation
     * @param random Random instance to use for jitter calculation
     * @return Duration representing the delay before the next retry
     */
    static Duration calculateDelay(int retryCount, Duration baseDelay, Random random) {
        if (retryCount < 0) {
            return Duration.ZERO;
        }

        // Use provided base delay (caller must provide a valid value)
        if (baseDelay == null) {
            throw new IllegalArgumentException("baseDelay cannot be null");
        }
        if (baseDelay.isNegative()) {
            throw new IllegalArgumentException("baseDelay cannot be negative");
        }
        if (baseDelay.isZero()) {
            throw new IllegalArgumentException("baseDelay cannot be zero");
        }
        long baseDelayMs = baseDelay.toMillis();

        // Calculate exponential delay: 2^retryCount * baseDelay
        long exponentialDelayMs = (long) Math.pow(2, retryCount) * baseDelayMs;

        // Cap at maximum delay
        long maxDelayMs = MAX_DELAY_SECONDS * 1000L;
        if (exponentialDelayMs > maxDelayMs) {
            exponentialDelayMs = maxDelayMs;
        }

        // Add jitter: random value between exponentialDelay and 2 * exponentialDelay
        long minDelayMs = exponentialDelayMs;
        long maxDelayMsWithJitter = Math.min(exponentialDelayMs * 2, maxDelayMs);

        // Generate random delay within the jitter range
        long jitterRange = maxDelayMsWithJitter - minDelayMs;
        long actualDelayMs = minDelayMs + (jitterRange > 0 ? (long) (random.nextDouble() * (jitterRange + 1)) : 0);

        return Duration.ofMillis(actualDelayMs);
    }
}
