/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import java.time.Duration;
import java.util.Random;

/**
 * Utility class for calculating exponential backoff delays with jitter.
 *
 * Implements the retry strategy specified in GitHub issue #155:
 * - Base delay: 2^retryCount * 500ms
 * - Jitter: Random value between base and 2 * base
 * - Maximum delay: 120 seconds (capped after 8th retry)
 */
public class ExponentialBackoff {

    private static final int BASE_DELAY_MS = 500;
    private static final int MAX_DELAY_SECONDS = 120;
    private static final Random RANDOM = new Random();

    private ExponentialBackoff() {
        // Utility class - no instantiation
    }

    /**
     * Calculates the exponential backoff delay with jitter for a given retry attempt.
     *
     * @param retryCount The current retry attempt (0-based, so first retry is 0)
     * @return Duration representing the delay before the next retry
     */
    public static Duration calculateDelay(int retryCount) {
        if (retryCount < 0) {
            return Duration.ZERO;
        }

        // Calculate base delay: 2^retryCount * 500ms
        long baseDelayMs = (long) Math.pow(2, retryCount) * BASE_DELAY_MS;

        // Cap at maximum delay
        long maxDelayMs = MAX_DELAY_SECONDS * 1000L;
        if (baseDelayMs > maxDelayMs) {
            baseDelayMs = maxDelayMs;
        }

        // Add jitter: random value between baseDelay and 2 * baseDelay
        long minDelayMs = baseDelayMs;
        long maxDelayMsWithJitter = Math.min(baseDelayMs * 2, maxDelayMs);

        // Generate random delay within the jitter range
        long jitterRange = maxDelayMsWithJitter - minDelayMs;
        long actualDelayMs = minDelayMs + (jitterRange > 0 ? (long) (RANDOM.nextDouble() * (jitterRange + 1)) : 0);

        return Duration.ofMillis(actualDelayMs);
    }

    /**
     * Calculates the exponential backoff delay with jitter using a provided Random instance.
     * This method is primarily for testing purposes to ensure deterministic behavior.
     *
     * @param retryCount The current retry attempt (0-based, so first retry is 0)
     * @param random Random instance to use for jitter calculation
     * @return Duration representing the delay before the next retry
     */
    public static Duration calculateDelay(int retryCount, Random random) {
        if (retryCount < 0) {
            return Duration.ZERO;
        }

        // Calculate base delay: 2^retryCount * 500ms
        long baseDelayMs = (long) Math.pow(2, retryCount) * BASE_DELAY_MS;

        // Cap at maximum delay
        long maxDelayMs = MAX_DELAY_SECONDS * 1000L;
        if (baseDelayMs > maxDelayMs) {
            baseDelayMs = maxDelayMs;
        }

        // Add jitter: random value between baseDelay and 2 * baseDelay
        long minDelayMs = baseDelayMs;
        long maxDelayMsWithJitter = Math.min(baseDelayMs * 2, maxDelayMs);

        // Generate random delay within the jitter range
        long jitterRange = maxDelayMsWithJitter - minDelayMs;
        long actualDelayMs = minDelayMs + (jitterRange > 0 ? (long) (random.nextDouble() * (jitterRange + 1)) : 0);

        return Duration.ofMillis(actualDelayMs);
    }
}
