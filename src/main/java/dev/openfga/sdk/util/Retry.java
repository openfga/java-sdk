/*
 * OpenFGA
 * A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 *
 * The version of the OpenAPI document: 1.x
 * Contact: community@openfga.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.openfga.sdk.util;

import java.time.Duration;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Helper methods for retry strategies.
 */
public class Retry {
    private Retry() {}

    /**
     * Parse the Retry-After header value to a Duration in seconds.
     * Returns null if the value is invalid or outside the allowed range (1s-30min).
     */
    public static Duration parseRetryAfter(String headerValue) {
        if (StringUtil.isNullOrWhitespace(headerValue)) {
            return null;
        }

        String value = headerValue.trim();
        // Try integer seconds first
        try {
            long secs = Long.parseLong(value);
            if (secs < 1 || secs > 1800) {
                return null;
            }
            return Duration.ofSeconds(secs);
        } catch (NumberFormatException ex) {
            // try HTTP date
            try {
                OffsetDateTime date = OffsetDateTime.parse(value, DateTimeFormatter.RFC_1123_DATE_TIME);
                long secs = Duration.between(OffsetDateTime.now(), date).getSeconds();
                if (secs < 1 || secs > 1800) {
                    return null;
                }
                return Duration.ofSeconds(secs);
            } catch (DateTimeParseException e) {
                return null;
            }
        }
    }

    /**
     * Parse Retry-After header value returning seconds as Long. Returns null when invalid.
     */
    public static Long parseRetryAfterSeconds(String headerValue) {
        Duration d = parseRetryAfter(headerValue);
        return d != null ? d.getSeconds() : null;
    }

    /**
     * Compute an exponential backoff with jitter based on the retry number.
     * The result is capped at 120 seconds.
     */
    public static Duration computeExponentialDelay(Duration baseDelay, int retryNumber) {
        long baseMillis = baseDelay.toMillis();
        long minMillis = (long) Math.pow(2, retryNumber) * baseMillis;
        long maxMillis = (long) Math.pow(2, retryNumber + 1) * baseMillis;
        long cap = 120_000L; // 120 seconds
        minMillis = Math.min(minMillis, cap);
        maxMillis = Math.min(maxMillis, cap);
        long delay;
        if (minMillis == maxMillis) {
            delay = minMillis;
        } else {
            delay = ThreadLocalRandom.current().nextLong(minMillis, maxMillis + 1);
        }
        return Duration.ofMillis(delay);
    }
}
